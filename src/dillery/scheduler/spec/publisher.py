# @formatter:off
"""
This module was generated by asynchron application, see https://github.com/zerlok/asynchron

Config          docs/services/scheduler/asyncapi.yaml
Created at      2022-02-08T07:00:34
Author          zerlok

"""

from asynchron.amqp.controller import AioPikaBasedAmqpController
from asynchron.amqp.serializer.pydantic import PydanticMessageSerializer
from asynchron.core.amqp import AmqpPublisherBindings
from asynchron.core.publisher import MessagePublisher

from .message import (
    AcceptedTask,
    CancelledTask,
    PerformedTask,
)




class DillerySchedulerServicePublisherFacade:
    """Background task scheduling service. Manages the whole task pipeline. 

Clients should *post* their task and may listen to desired stages of the task exection.

## Task execution pipeline

### Diagram

posted --> accepted --> started --> finished -->> performed
   |                       |
   |                        ` -------------------->> failed
   |
    ` ----------------------------------------->> cancelled

### Stages

#### posted
Initial stage. A new task was published by a client.

#### canelled
Final stage. A task can't be accepted for execution for some reason (task data is invalid, task policy check failed,
etc).

#### accepted
A task was accepted for execution by scheduler 

#### started
A task execution was started by worker

#### failed
A task execution was failed by worker

#### finished
A task execution was finished successfully

#### performed
Final stage. A task pipeline is finished.
"""

    def __init__(
            self,
            controller: AioPikaBasedAmqpController,
    ) -> None:
        self.__task_accepted_publisher: MessagePublisher[AcceptedTask] = controller.bind_publisher(
            encoder=PydanticMessageSerializer(
                model=AcceptedTask,  # type: ignore[misc]
            ),
            bindings=AmqpPublisherBindings(
                exchange_name="dillery",
                routing_key="task.accepted",
                is_mandatory=None,
                prefetch_count=None,
            ),
        )
        self.__task_cancelled_publisher: MessagePublisher[CancelledTask] = controller.bind_publisher(
            encoder=PydanticMessageSerializer(
                model=CancelledTask,  # type: ignore[misc]
            ),
            bindings=AmqpPublisherBindings(
                exchange_name="dillery",
                routing_key="task.cancelled",
                is_mandatory=None,
                prefetch_count=None,
            ),
        )
        self.__task_performed_publisher: MessagePublisher[PerformedTask] = controller.bind_publisher(
            encoder=PydanticMessageSerializer(
                model=PerformedTask,  # type: ignore[misc]
            ),
            bindings=AmqpPublisherBindings(
                exchange_name="dillery",
                routing_key="task.performed",
                is_mandatory=None,
                prefetch_count=None,
            ),
        )

    async def publish_task_accepted(
            self,
            message: AcceptedTask,
    ) -> None:
        await self.__task_accepted_publisher.publish(message)

    async def publish_task_cancelled(
            self,
            message: CancelledTask,
    ) -> None:
        await self.__task_cancelled_publisher.publish(message)

    async def publish_task_performed(
            self,
            message: PerformedTask,
    ) -> None:
        await self.__task_performed_publisher.publish(message)







# @formatter:on
