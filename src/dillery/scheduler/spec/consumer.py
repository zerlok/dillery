# @formatter:off
"""
This module was generated by asynchron application, see https://github.com/zerlok/asynchron

Config          docs/services/scheduler/asyncapi.yaml
Created at      2022-02-08T07:00:34
Author          zerlok

"""

import abc

from asynchron.amqp.controller import AioPikaBasedAmqpController
from asynchron.amqp.serializer.pydantic import PydanticMessageSerializer
from asynchron.core.amqp import AmqpConsumerBindings
from asynchron.core.consumer import CallableMessageConsumer

from .message import (
    FailedTask,
    FinishedTask,
    PostedTask,
    StartedTask,
)




class DillerySchedulerServiceConsumerFacade(metaclass=abc.ABCMeta):
    """Background task scheduling service. Manages the whole task pipeline. 

Clients should *post* their task and may listen to desired stages of the task exection.

## Task execution pipeline

### Diagram

posted --> accepted --> started --> finished -->> performed
   |                       |
   |                        ` -------------------->> failed
   |
    ` ----------------------------------------->> cancelled

### Stages

#### posted
Initial stage. A new task was published by a client.

#### canelled
Final stage. A task can't be accepted for execution for some reason (task data is invalid, task policy check failed,
etc).

#### accepted
A task was accepted for execution by scheduler 

#### started
A task execution was started by worker

#### failed
A task execution was failed by worker

#### finished
A task execution was finished successfully

#### performed
Final stage. A task pipeline is finished.
"""

    def __init__(
            self,
            controller: AioPikaBasedAmqpController,
    ) -> None:
        controller.bind_consumer(
            decoder=PydanticMessageSerializer(
                model=FailedTask,  # type: ignore[misc]
            ),
            consumer=CallableMessageConsumer(
                consumer=self.consume_task_failed,
            ),
            bindings=AmqpConsumerBindings(
                exchange_name="dillery",
                binding_keys=(
                    "task.failed",
                ),
                queue_name=None,
                is_auto_delete_enabled=None,
                is_exclusive=None,
                is_durable=None,
                prefetch_count=None,
            ),
        )
        controller.bind_consumer(
            decoder=PydanticMessageSerializer(
                model=FinishedTask,  # type: ignore[misc]
            ),
            consumer=CallableMessageConsumer(
                consumer=self.consume_task_finished,
            ),
            bindings=AmqpConsumerBindings(
                exchange_name="dillery",
                binding_keys=(
                    "task.finished",
                ),
                queue_name=None,
                is_auto_delete_enabled=None,
                is_exclusive=None,
                is_durable=None,
                prefetch_count=None,
            ),
        )
        controller.bind_consumer(
            decoder=PydanticMessageSerializer(
                model=PostedTask,  # type: ignore[misc]
            ),
            consumer=CallableMessageConsumer(
                consumer=self.consume_task_posted,
            ),
            bindings=AmqpConsumerBindings(
                exchange_name="dillery",
                binding_keys=(
                    "task.posted",
                ),
                queue_name="posted-tasks",
                is_auto_delete_enabled=True,
                is_exclusive=None,
                is_durable=None,
                prefetch_count=100,
            ),
        )
        controller.bind_consumer(
            decoder=PydanticMessageSerializer(
                model=StartedTask,  # type: ignore[misc]
            ),
            consumer=CallableMessageConsumer(
                consumer=self.consume_task_started,
            ),
            bindings=AmqpConsumerBindings(
                exchange_name="dillery",
                binding_keys=(
                    "task.started",
                ),
                queue_name=None,
                is_auto_delete_enabled=None,
                is_exclusive=None,
                is_durable=None,
                prefetch_count=None,
            ),
        )

    @abc.abstractmethod
    async def consume_task_failed(
            self,
            message: FailedTask,
    ) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    async def consume_task_finished(
            self,
            message: FinishedTask,
    ) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    async def consume_task_posted(
            self,
            message: PostedTask,
    ) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    async def consume_task_started(
            self,
            message: StartedTask,
    ) -> None:
        raise NotImplementedError







# @formatter:on
